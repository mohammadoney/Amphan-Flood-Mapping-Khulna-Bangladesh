// -------------------------
// INPUT DATASETS & DATES
// -------------------------
var gsw        = ee.Image("JRC/GSW1_2/GlobalSurfaceWater");
var admin2     = ee.FeatureCollection("FAO/GAUL_SIMPLIFIED_500m/2015/level2");
var hydrosheds = ee.Image("WWF/HydroSHEDS/03VFDEM");

var beforeStart = '2020-04-25';
var beforeEnd   = '2020-05-15';
var afterStart  = '2020-05-16';
var afterEnd    = '2020-06-05';

// -------------------------
// STUDY AREA: KHULNA
// -------------------------
var table = ee.FeatureCollection("FAO/GAUL_SIMPLIFIED_500m/2015/level2");
var geometry = table
  .filter(ee.Filter.eq("ADM2_NAME", "Khulna"))
  .geometry();

print('Khulna geometry', geometry);
Map.addLayer(geometry, {color: 'grey'}, 'Khulna');
Map.centerObject(geometry, 9);

// -------------------------
// SENTINEL-1 COLLECTION
// -------------------------
var collection = ee.ImageCollection('COPERNICUS/S1_GRD')
  .filter(ee.Filter.eq('instrumentMode','IW'))
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
  .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING')) 
  .filter(ee.Filter.eq('resolution_meters',10))
  .filterBounds(geometry)
  .select('VH');

var beforeCollection = collection.filterDate(beforeStart, beforeEnd);
var afterCollection  = collection.filterDate(afterStart, afterEnd);

var before = beforeCollection.mosaic().clip(geometry);
var after  = afterCollection.mosaic().clip(geometry);

// -------------------------
// SPECKLE FILTERING
// -------------------------
function toNatural(img) {
  return ee.Image(10.0).pow(img.select(0).divide(10.0));
}

function toDB(img) {
  return ee.Image(img).log10().multiply(10.0);
}

// Refined Lee (Guido Lemoine)
function RefinedLee(img) {
  // img must be in natural units, i.e. not in dB!
  var weights3 = ee.List.repeat(ee.List.repeat(1,3),3);
  var kernel3 = ee.Kernel.fixed(3,3, weights3, 1, 1, false);

  var mean3 = img.reduceNeighborhood(ee.Reducer.mean(), kernel3);
  var variance3 = img.reduceNeighborhood(ee.Reducer.variance(), kernel3);

  var sample_weights = ee.List([
    [0,0,0,0,0,0,0],
    [0,1,0,1,0,1,0],
    [0,0,0,0,0,0,0],
    [0,1,0,1,0,1,0],
    [0,0,0,0,0,0,0],
    [0,1,0,1,0,1,0],
    [0,0,0,0,0,0,0]
  ]);
  var sample_kernel = ee.Kernel.fixed(7,7, sample_weights, 3,3, false);

  var mean3Bands = mean3.neighborhoodToBands(sample_kernel); 
  var var3Bands  = variance3.neighborhoodToBands(sample_kernel);

  var gradients = mean3Bands.select(1).subtract(mean3Bands.select(7)).abs();
  gradients = gradients.addBands(mean3Bands.select(6).subtract(mean3Bands.select(2)).abs());
  gradients = gradients.addBands(mean3Bands.select(3).subtract(mean3Bands.select(5)).abs());
  gradients = gradients.addBands(mean3Bands.select(0).subtract(mean3Bands.select(8)).abs());

  var max_gradient = gradients.reduce(ee.Reducer.max());
  var gradmask = gradients.eq(max_gradient);
  gradmask = gradmask.addBands(gradmask);

  var directions = mean3Bands.select(1)
    .subtract(mean3Bands.select(4))
    .gt(mean3Bands.select(4).subtract(mean3Bands.select(7))).multiply(1);
  directions = directions.addBands(
    mean3Bands.select(6).subtract(mean3Bands.select(4))
      .gt(mean3Bands.select(4).subtract(mean3Bands.select(2))).multiply(2));
  directions = directions.addBands(
    mean3Bands.select(3).subtract(mean3Bands.select(4))
      .gt(mean3Bands.select(4).subtract(mean3Bands.select(5))).multiply(3));
  directions = directions.addBands(
    mean3Bands.select(0).subtract(mean3Bands.select(4))
      .gt(mean3Bands.select(4).subtract(mean3Bands.select(8))).multiply(4));

  directions = directions.addBands(directions.select(0).not().multiply(5));
  directions = directions.addBands(directions.select(1).not().multiply(6));
  directions = directions.addBands(directions.select(2).not().multiply(7));
  directions = directions.addBands(directions.select(3).not().multiply(8));

  directions = directions.updateMask(gradmask);
  directions = directions.reduce(ee.Reducer.sum());

  var sample_stats = var3Bands.divide(mean3Bands.multiply(mean3Bands));
  var sigmaV = sample_stats.toArray().arraySort().arraySlice(0,0,5)
    .arrayReduce(ee.Reducer.mean(), [0]);

  var rect_weights = ee.List.repeat(ee.List.repeat(0,7),3)
    .cat(ee.List.repeat(ee.List.repeat(1,7),4));
  var diag_weights = ee.List([
    [1,0,0,0,0,0,0],
    [1,1,0,0,0,0,0],
    [1,1,1,0,0,0,0],
    [1,1,1,1,0,0,0],
    [1,1,1,1,1,0,0],
    [1,1,1,1,1,1,0],
    [1,1,1,1,1,1,1]
  ]);

  var rect_kernel = ee.Kernel.fixed(7,7, rect_weights, 3, 3, false);
  var diag_kernel = ee.Kernel.fixed(7,7, diag_weights, 3, 3, false);

  var dir_mean = img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel)
    .updateMask(directions.eq(1));
  var dir_var  = img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel)
    .updateMask(directions.eq(1));

  dir_mean = dir_mean.addBands(
    img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel)
      .updateMask(directions.eq(2)));
  dir_var = dir_var.addBands(
    img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel)
      .updateMask(directions.eq(2)));

  for (var i = 1; i < 4; i++) {
    dir_mean = dir_mean.addBands(
      img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel.rotate(i))
        .updateMask(directions.eq(2*i+1)));
    dir_var = dir_var.addBands(
      img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel.rotate(i))
        .updateMask(directions.eq(2*i+1)));

    dir_mean = dir_mean.addBands(
      img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel.rotate(i))
        .updateMask(directions.eq(2*i+2)));
    dir_var = dir_var.addBands(
      img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel.rotate(i))
        .updateMask(directions.eq(2*i+2)));
  }

  dir_mean = dir_mean.reduce(ee.Reducer.sum());
  dir_var  = dir_var.reduce(ee.Reducer.sum());

  var varX = dir_var.subtract(dir_mean.multiply(dir_mean).multiply(sigmaV))
    .divide(sigmaV.add(1.0));
  var b = varX.divide(dir_var);
  var result = dir_mean.add(b.multiply(img.subtract(dir_mean)));

  return result.arrayFlatten([['sum']]);
}

var beforeFiltered = ee.Image(toDB(RefinedLee(toNatural(before))));
var afterFiltered  = ee.Image(toDB(RefinedLee(toNatural(after))));

// -------------------------
// FLOOD DETECTION
// -------------------------
var difference = afterFiltered.divide(beforeFiltered);

var diffThreshold = 1.25;

// Initial flooded mask (boolean)
// Rename band to 'flooded' for consistency
var flooded = difference.gt(diffThreshold)
  .rename('flooded')
  .selfMask();

// -------------------------
// MASK PERMANENT/SEASONAL WATER
// -------------------------
var permanentWater = gsw.select('seasonality')
  .gte(5)               // water present >= 5 months
  .clip(geometry);

flooded = flooded.where(permanentWater, 0).selfMask();

// -------------------------
// MASK SLOPES > 5Â°
// -------------------------
var slopeThreshold = 5;
var terrain = ee.Algorithms.Terrain(hydrosheds);
var slope = terrain.select('slope');

flooded = flooded.updateMask(slope.lt(slopeThreshold));

// -------------------------
// REMOVE ISOLATED PIXELS
// -------------------------
var connectedPixelThreshold = 8;
var connections = flooded.connectedPixelCount(25);

flooded = flooded
  .updateMask(connections.gt(connectedPixelThreshold))
  .clip(geometry);  // ensure only inside Khulna

// Visualize
Map.addLayer(flooded, {min:0, max:1, palette: ['red']}, 'Flooded Areas (Khulna only)');

// -------------------------
// EXPORT SINGLE-BAND FLOODED TIFF
// -------------------------
Export.image.toDrive({
  image: flooded.selfMask(),       // single band 'flooded'
  description: 'Khulna_Flooded_Areas_Export',
  folder: 'earthengine',
  fileNamePrefix: 'khulna_flooded_areas',
  scale: 10,
  region: geometry,                // only Khulna extent
  maxPixels: 1e10,
  fileFormat: 'GeoTIFF',
  formatOptions: {
    cloudOptimized: true
  }
});

// -------------------------
// AREA CALCULATIONS
// -------------------------
print('Total District Area (Ha)', geometry.area().divide(10000));

var stats = flooded.multiply(ee.Image.pixelArea()).reduceRegion({
  reducer: ee.Reducer.sum(),
  geometry: geometry,
  scale: 10,
  maxPixels: 1e10,
  tileScale: 16
});

// band name is now 'flooded'
var flooded_area = ee.Number(stats.get('flooded')).divide(10000);
print('Flooded Area (Ha)', flooded_area);

// flooded_area is a ee.Number of hectares (as you already computed)
var flooded_area = ee.Number(stats.get('flooded')).divide(10000);

// Make a feature with null geometry and the flooded_area property
var feature = ee.Feature(null, {
  'ADM2_NAME': 'Khulna',
  'flooded_area_ha': flooded_area
});

// Wrap in a FeatureCollection
var fc = ee.FeatureCollection([feature]);

// Export the table (CSV) to Drive
Export.table.toDrive({
  collection: fc,
  description: 'Khulna_Flooded_Area_Hectares',
  folder: 'earthengine',
  fileNamePrefix: 'khulna_flooded_area_ha',
  fileFormat: 'CSV'
});


